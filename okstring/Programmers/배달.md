### ë°°ë‹¬

ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì€

-  Cycle ( ë‘ ì •ì ì´ ì„œë¡œë¥¼ í–¥í•˜ê³  ìˆëŠ” ê²ƒ ) ì´ ì—†ëŠ” ê·¸ë˜í”„
- Weighted ê·¸ë˜í”„ ( ê·¸ë˜í”„ì˜ ê°„ì„ ì— ê°€ì¤‘ì¹˜ë¥¼ ì¤€ ê°€ì¤‘ ê·¸ë˜í”„ ) ì—ì„œ ì“¸ ìˆ˜ ìˆë‹¤. 
- í•˜ì§€ë§Œ ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ìˆìœ¼ë©´ ì•ˆëœë‹¤. ë§Œì•½ ìŒì˜ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§„ ê·¸ë˜í”„ì—ì„œ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ê³  ì‹¶ìœ¼ë©´ ë²¨ë§Œ - í¬ë“œ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ë©´ ëœë‹¤ 
- í”Œë¡œì´ë“œ í’€ì´ë„ ì°¸ê³ 



### ìŠ¤í„°ë””ì› ì­ì˜ ì •ë¦¬

- `ë‹¤ìµìŠ¤íŠ¸ë¼`: í•˜ë‚˜ì˜ ì •ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ìœ¼ë¡œì˜ ìµœë‹¨ ê²½ë¡œ
- `í”Œë¡œì´ë“œ ì™€ìƒ¬`: ëª¨ë“  ì •ì ì—ì„œ ëª¨ë“  ì •ì ìœ¼ë¡œì˜ ìµœë‹¨ ê²½ë¡œ

- `í”Œë¡œì´ë“œ ì™€ìƒ¬` ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ì€ **ê±°ì³ê°€ëŠ” ì •ì **ì„ ê¸°ì¤€ìœ¼ë¡œ ì•Œê³ ë¦¬ì¦˜ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒ! `for`ë¬¸ì„ ì„¸ ë²ˆ ëŒë ¤ ê±°ì³ê°€ëŠ” ì •ì ì„ í†µí•´ ìµœì†Œ ë¹„ìš©ì„ êµ¬í•˜ëŠ” íë¦„ì€ `í”Œë¡œì´ë“œ ì™€ìƒ¬` í’€ì´ì˜ í•µì‹¬ì¸ ë“¯ í•˜ë‹ˆ ì˜ ê¸°ì–µí•´ë‘ë„ë¡ í•˜ì! (ì°¸ê³ : [ë‚˜ë™ë¹ˆë‹˜ ë¸”ë¡œê·¸](https://m.blog.naver.com/PostView.nhn?blogId=ndb796&logNo=221234427842&proxyReferer=https:%2F%2Fwww.google.com%2F))
- í•œ ì •ì ì„ ê¸°ì¤€ìœ¼ë¡œ ê±°ë¦¬ë¥¼ êµ¬í•˜ë©´ ë˜ëŠ” `ë‹¤ìµìŠ¤íŠ¸ë¼`ì˜ ì „í˜• ê°™ì€ ë¬¸ì œì´ë‹ˆ ê¼­ ì´ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•´ì„œë„ í’€ì–´ë³´ë„ë¡ í•˜ì! (2ì£¼ í›„ ë¦¬ë§ˆì¸ë” ë§ì¶°ë†“ìŒğŸ””)

### 



### ë¸”ë¡œê±°ì˜ í’€ì´

allRoutesê°€ ì™œ í•„ìš”í•œì§€ ëª¨ë¥´ê² ë‹¤

[https://fomaios.tistory.com/entry/Algorithm-ë‹¤ìµìŠ¤íŠ¸ë¼-Dijkstra-ì•Œê³ ë¦¬ì¦˜ì´ë€](https://fomaios.tistory.com/entry/Algorithm-ë‹¤ìµìŠ¤íŠ¸ë¼-Dijkstra-ì•Œê³ ë¦¬ì¦˜ì´ë€)

```swift
import Foundation




func solution(_ N:Int, _ road:[[Int]], _ k:Int) -> Int {
    let start = 1
    //allRoutesì—ëŠ” ê°€ì¥ ì§§ì€ ê±°ë¦¬ë¡œ ê°€ëŠ” ê²½ë¡œê°€ ìˆœì„œëŒ€ë¡œ ë‹´ê¸°ê²Œ ëœë‹¤.
    //ê²½ë¡œ ì €ì¥ ë°°ì—´
    var allRoutes = (0...N).map{[$0]}
    //ê±°ë¦¬ ì €ì¥ ë°°ì—´
    var allDistances = Array(repeating: Int.max, count: N+1)
    
    func dijkstra() {
        //ìê¸° ìì‹ ê³¼ì˜ ê±°ë¦¬ëŠ” 0
        allDistances[start] = 0
        var queue:[Int] = [start]
        while !queue.isEmpty {
            let first = queue.removeFirst()
            
            //ì¶œë°œì§€ ë˜ëŠ” ë„ì°©ì§€ê°€ firstì¸ ê°’ filter
            let filterNodes = road.filter{ $0[0] == first || $0[1] == first }
        
            //í•„í„°ë§í•œ ê²ƒë“¤ì„ ìˆœíšŒ
            for filterNode in filterNodes {
                //ì²«ë²ˆì§¸ ê°’ì´ ì•„ë‹Œ ê²ƒì„ otherë¡œ ì„¤ì •?? - ì´ì–´ì§„ ë…¸ë“œë¥¼ ë³€ìˆ˜ì— í• ë‹¹
                let connectionNode = filterNode[0] == first ? filterNode[1] : filterNode[0]
                //ë§Œì•½ Int ìµœëŒ“ê°’ì´ë¼ë©´ continue
                if allDistances[first] == Int.max { continue }
                
                //ì²«ë²ˆì§¸ ê°’ì— ì´ì–´ì§„ ë…¸ë“œ ê±°ë¦¬ ê°’ì„ ë”í•œ ê²ƒì´ ì›ë˜ ìˆëŠ” ê°’ë³´ë‹¤ ì‘ë‹¤ë©´
                if allDistances[first] + filterNode[2] < allDistances[connectionNode] {
                    
                    //ì²«ë²ˆì§¸ ê°’ì— ê±°ë¦¬ë¥¼ ë”í•œ ê²ƒìœ¼ë¡œ ì—…ë°ì´íŠ¸
                    allDistances[connectionNode] = allDistances[first] + filterNode[2]
                    
                    //í˜„ì¬ ë…¸ë“œë¥¼ ì¶”ê°€í•´ì¤Œ.
                    allRoutes[first].append(connectionNode)
                    //í˜„ì¬ ë…¸ë“œë¥¼ ìƒˆë¡œìš´ ê²½ë¡œë¡œ ë°”ê¿”ì¤Œ.
                    allRoutes[connectionNode] = allRoutes[first]
                    //í˜„ì¬ ë…¸ë“œë¥¼ íì— ë„£ì–´ì¤Œ.
                    queue.append(connectionNode)
                }
            }
        }
    }
    
    dijkstra()
    print(allDistances)
    print(allRoutes)
    return allDistances.filter({ $0 <= k }).count
}


print(solution(5, [[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]], 3))
print(solution(6, [[1,2,1],[1,3,2],[2,3,2],[3,4,3],[3,5,2],[3,5,3],[5,6,1]], 4))

```





### ë¬¸ì œ ì¡°ê±´ì—ë§Œ ì¶©ì¡±í•˜ëŠ” ì½”ë“œë¡œ ì •ë¦¬

```swift
import Foundation

func solution(_ N:Int, _ road:[[Int]], _ k:Int) -> Int {
    let start = 1
    var allDistances = Array(repeating: Int.max, count: N+1)
    func dijkstra() {
        allDistances[start] = 0
        var queue:[Int] = [start]
        while !queue.isEmpty {
            let first = queue.removeFirst()
            let filterNodes = road.filter{ $0[0] == first || $0[1] == first }
            for filterNode in filterNodes {
                let connectionNode = filterNode[0] == first ? filterNode[1] : filterNode[0]
                if allDistances[first] == Int.max { continue } // ì—†ë°ì´íŠ¸ ëœ ê°’ë“¤ë§Œ, 01 Matrix
                if allDistances[first] + filterNode[2] < allDistances[connectionNode] {
                    allDistances[connectionNode] = allDistances[first] + filterNode[2]
                    queue.append(connectionNode)
                }
            }
        }
    }
    dijkstra()
    return allDistances.filter({ $0 <= k }).count
}
```

