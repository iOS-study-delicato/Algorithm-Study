# Baekjoon

## [ìµœë‹¨ê²½ë¡œ](https://www.acmicpc.net/problem/1753)

* ë¶„ë¥˜: ê·¸ë˜í”„ ì´ë¡ , ë‹¤ìµìŠ¤íŠ¸ë¼
* í’€ì´ ì–¸ì–´: Swift
* ë¬¸ì œ ìš”ì•½: ê°€ì¤‘ì¹˜ ë°©í–¥ê·¸ë˜í”„ì˜ ì‹œì‘ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ìœ¼ë¡œì˜ ìµœë‹¨ ê²½ë¡œê°’ì„ ì¶œë ¥

### ì½”ë“œ

```swift
// [swiftë¡œ ê°„ë‹¨í•˜ê²Œ êµ¬í˜„í•œ í™](https://gist.github.com/JCSooHwanCho/a3f070c2160bb8c0047a5ddbb831f78e)
public struct Heap<T> {
  var nodes: [T] = []
  let comparer: (T,T) -> Bool

  var isEmpty: Bool {
      return nodes.isEmpty
  }

  init(comparer: @escaping (T,T) -> Bool) {
      self.comparer = comparer
  }

  func peek() -> T? {
      return nodes.first
  }

  mutating func insert(_ element: T) {
      var index = nodes.count

      nodes.append(element)

      while index > 0, !comparer(nodes[index],nodes[(index-1)/2]) {
          nodes.swapAt(index, (index-1)/2)
          index = (index-1)/2
      }
  }

  mutating func delete() -> T? {
      guard !nodes.isEmpty else {
          return nil
      }

      if nodes.count == 1 {
          return nodes.removeFirst()
      }

      let result = nodes.first
      nodes.swapAt(0, nodes.count-1)
      _ = nodes.popLast()

      var index = 0

      while index < nodes.count {
          let left = index * 2 + 1
          let right = left + 1

          if right < nodes.count {
              if comparer(nodes[left], nodes[right]),
                  !comparer(nodes[right], nodes[index]) {
                  nodes.swapAt(right, index)
                  index = right
              } else if !comparer(nodes[left], nodes[index]){
                  nodes.swapAt(left, index)
                  index = left
              } else {
                  break
              }
          } else if left < nodes.count {
              if !comparer(nodes[left], nodes[index]) {
                  nodes.swapAt(left, index)
                  index = left
              } else {
                  break
              }
          } else {
              break
          }
      }

      return result
  }
}

extension Heap where T: Comparable {
    init() {
        /// Min Heap
        self.init(comparer: >)
    }
}

struct Edge: Comparable {
    static func < (lhs: Edge, rhs: Edge) -> Bool {
        lhs.cost < rhs.cost
    }
    
    var node: Int
    var cost: Int
}

let ve = readLine()!.split(separator: " ").map { Int(String($0))! }
let (v, e) = (ve.first!, ve.last!)
let k = Int(readLine()!)! - 1
//let k = Int(readLine()!)!

var graph = [[(node: Int, cost: Int)]](repeating: [], count: v)
//var graph = [[(node: Int, cost: Int)]](repeating: [], count: v + 1)
var dist = [Int](repeating: Int.max, count: v)
//var dist = [Int](repeating: Int.max, count: v + 1)
dist[k] = 0

for _ in 0..<e {
    let uvw = readLine()!.split(separator: " ").map { Int(String($0))! }
    let (u, v, w) = (uvw[0] - 1, uvw[1] - 1, uvw[2])
    graph[u].append((v, w))
}

var queue = Heap<Edge>()
queue.insert(Edge(node: k, cost: 0))

while !queue.isEmpty {
    let cur = queue.delete()!
    if dist[cur.node] < cur.cost {
        continue
    }
    for next in graph[cur.node] {
        if cur.cost + next.cost < dist[next.node] {
            dist[next.node] = cur.cost + next.cost
            queue.insert(Edge(node: next.node, cost: cur.cost + next.cost))
        }
    }
}

var result = ""
for i in 0..<v {
//for i in 1...v {
    result += dist[i] != Int.max ? "\(dist[i])\n" : "INF\n"
}

print(result)
```

* ë©”ëª¨ë¦¬: 75740 KB
* ì‹œê°„: 580 ms

### íšŒê³ 

* ë‘ë²ˆì§¸ë¡œ í’€ì–´ë³¸ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ ìœ í˜•ì˜ ë¬¸ì œ. ì²«ë²ˆì§¸ ë¬¸ì œë¥¼ í’€ì—ˆì„ ë• ë‹¤ìµìŠ¤íŠ¸ë¼ì˜ ê°œë…ì¡°ì°¨ ì˜ ì´í•´ê°€ ê°€ì§€ ì•Šì•„ ì¢Œì ˆí–ˆëŠ”ë° ê·¸ë™ì•ˆ ê¾¸ì¤€íˆ ë¬¸ì œë¥¼ í’€ì–´ì˜¨ ë³´ëŒì´ ìˆëŠ” ê²ƒì¸ì§€ ì˜ˆì „ë³´ë‹¤ ìˆ˜ì›”íˆ ì´í•´ê°€ ë¼ ë¿Œë“¯í–ˆë‹¤.
* ë‹¤ë§Œ í‹€ë¦° ë¶€ë¶„ ì—†ì´ ë¡œì§ì„ ì˜ ì§°ë‹¤ê³  ìƒê°í–ˆëŠ”ë°ë„ ê³„ì† ë©”ëª¨ë¦¬ ì´ˆê³¼ í˜¹ì€ ì‹œê°„ ì´ˆê³¼ê°€.. í•˜í•˜ ë‚˜ í™˜ì¥ ğŸ˜‡
* **ë§ì•˜ìŠµë‹ˆë‹¤!!**ë¥¼ ë°›ê¸° ìœ„í•œ ëˆˆë¬¼ ê²¨ìš´ ì‹œë„ë“¤...
  * ì‹œë„ 1) ì¸ì ‘ í–‰ë ¬ë¡œ êµ¬í˜„í–ˆë˜ ê·¸ë˜í”„ë¥¼ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€ê²½
    * ì¸ì ‘ í–‰ë ¬ì˜ ì €ì¥ ê³µê°„: O(n<sup>2</sup>)
    * ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ì˜ ì €ì¥ ê³µê°„: O(n+m) (ìµœì•…ì˜ ê²½ìš° O(n<sup>2</sup>))
  * ì‹œë„ 2) ìš°ì„ ìˆœìœ„íë¥¼ ì´ìš©í•˜ê¸° ìœ„í•´ Heap êµ¬í˜„
    * ì—¬ëŸ¬ ìì˜ìì˜í•œ ì‹œë„ë“¤ì´ ë‹¤ ë¨¹íˆì§€ ì•Šì•„ ê²°êµ­ êµ¬ê¸€ë§. ìš°ì„ ìˆœìœ„íë¥¼ ì‚¬ìš©í•œ ë‹¤ìµìŠ¤íŠ¸ë¼ë¡œ í’€ ìˆ˜ ìˆìŒì„ ì•Œ ìˆ˜ ìˆì—ˆë‹¤. Heapì„ ì§ì ‘ êµ¬í˜„í•  ìì‹ ì´ ì—†ì–´ Rhynoë‹˜ì˜ [swiftë¡œ ê°„ë‹¨í•˜ê²Œ êµ¬í˜„í•œ í™](https://gist.github.com/JCSooHwanCho/a3f070c2160bb8c0047a5ddbb831f78e) ì½”ë“œë¥¼ ë³µë¶™!
    * ì´ ë¬¸ì œë¥¼ í’€ê¸° ìœ„í•´ì„  ìœ„ ë§í¬ì˜ ì½”ë“œì—ì„œ ìˆ˜ì •í•´ì¤˜ì•¼ í•  ë¶€ë¶„ì´ í•˜ë‚˜ ìˆë‹¤. ì½”ë“œ ë§ˆì§€ë§‰ ë¶€ë¶„ì—ì„œ Heapì„ í™•ì¥í•  ë•Œ `self.init(comparer: <)`ë¥¼ `self.init(comparer: >)`ë¡œ ê³ ì³ì£¼ì–´ì•¼ í•œë‹¤. Rhynoë‹˜ì˜ ì½”ë“œë¥¼ ì•„ì§ ì˜ ì´í•´í•˜ì§€ ëª»í•´ ì™œì¸ì§€ëŠ” ëª¨ë¥´ì§€ë§Œ ë¶€ë“±í˜¸ê°€ `>`ì¼ ë•Œ Min Heapì„ êµ¬í˜„í•  ìˆ˜ ìˆê³  ì´ ë¬¸ì œì—ì„  Min Heapì´ í•„ìš”í•œ ë“¯ í•˜ë‹¤. Rhynoë‹˜ì˜ ì½”ë“œë¥¼ ì°¬ì°¬íˆ ëœ¯ì–´ë³´ë©° Heapê³¼ Heap sortë¥¼ ë³µìŠµí•´ì•¼ë´ì•¼ê² ë‹¤.